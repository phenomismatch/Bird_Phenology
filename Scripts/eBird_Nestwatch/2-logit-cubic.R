######################
# 2 - logit cubic
#
# Fit logit cubic to eBird data to get half-max parameter (bird arrival) for each species-cell-year
#
# Formerly NA_birdPhen1.R
######################

# Loads the eBird dataset generated by Ebird_import.R, then uses Stan via the package
# rstanarm to fit a logit-cubic model to the reporting probability as a function of Julian Day in
# each species-cell-year that meets some data requirements. Several metrics are extracted from the
# fitted models. Most importantly, this is the derived half-max parameter, which is the Julian Day 
# when the fitted reporting probability first exceeds half of its maximum on the back-transformed
# identity scale, as well as a few convergence diagnostics. 


cy_dir <- '~/Google_Drive/R/'


# Load packages -----------------------------------------------------------

library(dggridR)
library(rstan)
library(rstanarm)

 air
 

# Set wd ------------------------------------------------------------------

setwd(paste0(cy_dir, 'Bird_Phenology/Data/'))



# import eBird species list -----------------------------------------------------

species_list_i <- read.table('eBird_species_list.txt')
species_list <- species_list_i[,1]
nsp <- length(species_list)



# Load in eBird data ------------------------------------------------------

setwd(paste0(cy_dir, 'Bird_Phenology/Data/Processed/'))

data_NA_birdPhen <- readRDS('ebird_NA_phen.rds')


# filter by criteria ------------------------------------------------------

'%ni%' <- Negate('%in%')

years <- 2002:2016
nyr <- length(years)

pdata <- data_NA_birdPhen[which(data_NA_birdPhen$PRIMARY_CHECKLIST_FLAG==1),]
pdata$EFFORT_HRS <- as.numeric(as.character(pdata$EFFORT_HRS))
pdata <- pdata[which(pdata$EFFORT_HRS > 0.1 & pdata$EFFORT_HRS<24), ]
pdata <- pdata[which(pdata$YEAR > 2001), ]
pdata <- pdata[-which(pdata$EFFORT_DISTANCE_KM == "?"),]
pdata <- pdata[-which((pdata$TIME + pdata$EFFORT_HRS) < 6), ]
pdata <- pdata[-which(pdata$TIME > 16), ]
pdata <- pdata[which(pdata$LONGITUDE > -100 & pdata$LONGITUDE < -50 & pdata$LATITUDE > 26), ]
pdata$EFFORT_DISTANCE_KM <- as.numeric(as.character(pdata$EFFORT_DISTANCE_KM))
pdata <- pdata[which(pdata$EFFORT_DISTANCE_KM >= 0 & pdata$EFFORT_DISTANCE_KM < 100),]



# Process data ------------------------------------------------------------

#convert to data.frame bc data.table is annoying
pdata2 <- as.data.frame(pdata)

for(i in 17:130)
{
  print(i)
  ttt <- pdata2[, i]
  ttt[which(ttt == "X")] <- 1
  ttt <- as.numeric(ttt)
  ttt[ttt > 0] <- 1
  if(min(ttt) < 0){stop()}
  pdata[, i] <- ttt
}


pdata$sjday <- as.vector(scale(as.numeric(as.character(pdata$DAY))))
pdata$sjday2 <- pdata$sjday^2
pdata$sjday3 <- pdata$sjday^3
pdata$shr <- as.vector(scale(pdata$EFFORT_HRS))

Mu.day <- mean(as.numeric(as.character(pdata$DAY)))
sd.day <- sd(as.numeric(as.character(pdata$DAY)))


# bin to hex grid ---------------------------------------------------------

# Construct geospatial hexagonal grid

hexgrid6 <- dggridR::dgconstruct(res=6) 
pdata$cell6 <- dggridR::dgGEO_to_SEQNUM(hexgrid6, pdata$LONGITUDE, pdata$LATITUDE)[[1]]
cells <- unique(pdata$cell6)
ncel <- length(cells)


# fit logit cubic models ---------------------------------------------------


predictDays = (c(1:200) - Mu.day)/sd.day
newdata <- data.frame(sjday = predictDays, sjday2 = predictDays^2, sjday3 = predictDays^3, shr = 1)

fit_diag <- halfmax_matrix_list <- list()

for(i in 1:nsp)
{
  #i <- 1
  fit_diag[[i]] <- halfmax_matrix_list[[i]] <- list()
  sdata <- pdata[,c("YEAR","DAY","sjday","sjday2","sjday3","shr","cell6",paste0(species_list[i]))]
  names(sdata)[8] <- "detect"
  
  for(j in 1:nyr)
  {
    #j <- 1
    halfmax_matrix_list[[i]][[j]] <- matrix(data = NA, nrow = ncel, ncol = 2000)
    fit_diag[[i]][[j]] <- list()
    ysdata <- sdata[which(sdata$YEAR == years[j]), ]
    
    for(k in 1:ncel)
    {
      #k <- 1
      print(paste(i,j,k))
      fit_diag[[i]][[j]][[k]] <- list(maxRhat = NA, mineffsSize = NA)
      cysdata <- ysdata[which(ysdata$cell6 == cells[k]), ]
      n1 <- sum(cysdata$detect)
      n0 <- sum(cysdata$detect == 0)
      #number of detections that came before jday 60
      n1W <- sum(cysdata$detect * as.numeric(cysdata$DAY < 60))
      
      if(n1 > 29 & n1W < (n1/50) & n0 > 29)
      {
        fit2 <- stan_glm(detect ~ sjday + sjday2 + sjday3 + shr, 
                         data = cysdata, 
                         family = binomial(link = "logit"), 
                         algorithm = 'sampling', 
                         iter = 5000, 
                         cores = 4)
        
        dfit <- posterior_linpred(fit2, newdata = newdata, transform = T)
        halfmax_fit <- rep(NA, 10000)
        
        # ############
        # #DIAGNOSTICS
        # 
        # summary(fit2)
        # 
        # mn_dfit <- apply(dfit, 2, mean)
        # LCI_dfit <- apply(dfit, 2, function(x) quantile(x, probs = 0.025))
        # UCI_dfit <- apply(dfit, 2, function(x) quantile(x, probs = 0.975))
        # 
        # plot(UCI_dfit, type = 'l', col = 'red', lty = 2, lwd = 2, ylim = c(0,1))
        # lines(LCI_dfit, col = 'red', lty = 2, lwd = 2)
        # lines(mn_dfit, lwd = 2)
        # points(cysdata$DAY, cysdata$detect, col = rgb(0,0,0,0.25))
        # 
        # ############
        
        
        
        for(L in 1:10000)
        {
          #L <- 1
          rowL <- as.vector(dfit[L,])
          halfmax_fit[L] <- min(which(rowL > (max(rowL)/2)))
        }
        
        halfmax_matrix_list[[i]][[j]][k,] <- halfmax_fit
        fit_diag[[i]][[j]][[k]]$maxRhat <- max(summary(fit2)[, "Rhat"])
        fit_diag[[i]][[j]][[k]]$mineffsSize <- min(summary(fit2)[, "n_eff"])
      }
    }
  }
}




setwd('~/Google_Drive/R/Bird_Phenology/Data/Processed/')

saveRDS(halfmax_matrix_list, file="halfmax_matrix_list.rds")
saveRDS(fit_diag, file="fit_diag.rds")

